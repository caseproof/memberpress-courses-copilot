<?php

namespace MemberPressCoursesCopilot\Models;

/**
 * Generated Course Model
 * 
 * Represents a complete course generated by the AI system.
 * Designed to integrate seamlessly with MemberPress Courses custom post types and meta fields.
 */
class GeneratedCourse
{
    private string $title;
    private string $description;
    private array $learningObjectives;
    private array $sections; // Array of CourseSection objects
    private array $metadata;
    private ?string $templateType;

    public function __construct(
        string $title,
        string $description = '',
        array $learningObjectives = [],
        array $sections = [],
        array $metadata = [],
        ?string $templateType = null
    ) {
        $this->title = $title;
        $this->description = $description;
        $this->learningObjectives = $learningObjectives;
        $this->sections = $sections;
        $this->metadata = $metadata;
        $this->templateType = $templateType;
    }

    /**
     * Validate course structure and content
     */
    public function validate(): array
    {
        $errors = [];

        if (empty(trim($this->title))) {
            $errors[] = 'Course title is required';
        }

        if (strlen($this->title) > 255) {
            $errors[] = 'Course title must be 255 characters or less';
        }

        if (empty(trim($this->description))) {
            $errors[] = 'Course description is required';
        }

        if (empty($this->learningObjectives)) {
            $errors[] = 'At least one learning objective is required';
        }

        if (empty($this->sections)) {
            $errors[] = 'At least one section is required';
        }

        // Validate learning objectives
        foreach ($this->learningObjectives as $index => $objective) {
            if (!is_string($objective) || empty(trim($objective))) {
                $errors[] = "Learning objective {$index} must be a non-empty string";
            }
        }

        // Validate each section
        foreach ($this->sections as $index => $section) {
            if (!$section instanceof CourseSection) {
                $errors[] = "Section {$index} must be a CourseSection instance";
                continue;
            }

            $sectionErrors = $section->validate();
            foreach ($sectionErrors as $sectionError) {
                $errors[] = "Section {$index}: {$sectionError}";
            }
        }

        return $errors;
    }

    /**
     * Convert course to MemberPress course format
     */
    public function toMemberPressFormat(): array
    {
        $sectionsData = [];
        foreach ($this->sections as $section) {
            $sectionsData[] = $section->toMemberPressFormat();
        }

        return [
            'post_title' => $this->title,
            'post_content' => $this->description,
            'post_status' => 'draft', // Start as draft for review
            'post_type' => 'mpcs-course', // MemberPress Courses course post type
            'meta_input' => array_merge([
                '_mpcs_course_learning_objectives' => $this->learningObjectives,
                '_mpcs_course_template_type' => $this->templateType,
                '_mpcs_course_sections_count' => count($this->sections),
                '_mpcs_course_total_lessons' => $this->getTotalLessons(),
                '_mpcs_course_estimated_duration' => $this->getEstimatedDuration(),
                '_mpcs_course_difficulty_level' => $this->getMetadata('difficulty_level', 'beginner'),
                '_mpcs_course_category' => $this->getMetadata('category', ''),
                '_mpcs_course_tags' => $this->getMetadata('tags', []),
                '_mpcs_course_prerequisites' => $this->getMetadata('prerequisites', []),
                '_mpcs_course_target_audience' => $this->getMetadata('target_audience', ''),
                '_mpcs_course_generated_by_ai' => true,
                '_mpcs_course_generation_timestamp' => current_time('timestamp')
            ], $this->formatMetadataForMemberPress()),
            'sections' => $sectionsData
        ];
    }

    /**
     * Format metadata for MemberPress custom fields
     */
    private function formatMetadataForMemberPress(): array
    {
        $memberPressMetadata = [];

        foreach ($this->metadata as $key => $value) {
            // Skip keys that are already handled above
            if (in_array($key, ['difficulty_level', 'category', 'tags', 'prerequisites', 'target_audience'])) {
                continue;
            }
            
            // Prefix with MemberPress Courses meta prefix
            $memberPressMetadata["_mpcs_course_{$key}"] = $value;
        }

        return $memberPressMetadata;
    }

    /**
     * Create WordPress course using MemberPress Courses models
     */
    public function createWordPressCourse(): int
    {
        // Use MemberPress Courses model if available
        if (class_exists('memberpress\\courses\\models\\Course')) {
            $course = new \memberpress\courses\models\Course();
            $course->post_title = $this->title;
            $course->post_content = $this->description;
            $course->post_status = 'draft';
            $course->post_author = get_current_user_id();
            
            // Save the course using MemberPress method
            $courseId = $course->store();
            
            if (!$courseId) {
                throw new \Exception('Failed to create MemberPress course');
            }
        } else {
            // Fallback to direct WordPress post creation
            $courseData = $this->toMemberPressFormat();
            $sectionsData = $courseData['sections'];
            unset($courseData['sections']);

            // Create the main course post
            $courseId = wp_insert_post($courseData);

            if (is_wp_error($courseId)) {
                throw new \Exception('Failed to create course: ' . $courseId->get_error_message());
            }
        }

        // Store additional metadata
        update_post_meta($courseId, 'mpcs_course_difficulty', $this->metadata['difficulty'] ?? 'intermediate');
        update_post_meta($courseId, 'mpcs_course_template_type', $this->templateType);
        update_post_meta($courseId, 'mpcs_course_generated_by_ai', true);
        update_post_meta($courseId, 'mpcs_course_generation_date', current_time('mysql'));
        update_post_meta($courseId, 'mpcs_learning_objectives', $this->learningObjectives);

        // Create sections and lessons
        if (isset($sectionsData)) {
            foreach ($sectionsData as $sectionIndex => $sectionData) {
                $this->createCourseSectionInWordPress($courseId, $sectionData, $sectionIndex);
            }
        } else {
            // Use object sections if we used MemberPress model
            foreach ($this->sections as $sectionIndex => $section) {
                if (method_exists($section, 'createInCourse')) {
                    $section->createInCourse($courseId, $sectionIndex);
                }
            }
        }

        return $courseId;
    }

    /**
     * Create course section and its lessons in WordPress
     */
    private function createCourseSectionInWordPress(int $courseId, array $sectionData, int $sectionOrder): void
    {
        // Store section metadata
        $sectionKey = "section_{$sectionOrder}";
        update_post_meta($courseId, "_mpcs_course_{$sectionKey}_title", $sectionData['section_title']);
        update_post_meta($courseId, "_mpcs_course_{$sectionKey}_order", $sectionData['section_order']);

        // Create lessons for this section
        foreach ($sectionData['lessons'] as $lessonIndex => $lessonData) {
            $lessonData['meta_input']['_mpcs_lesson_course_id'] = $courseId;
            $lessonData['meta_input']['_mpcs_lesson_section_index'] = $sectionOrder;
            $lessonData['meta_input']['_mpcs_lesson_section_title'] = $sectionData['section_title'];

            $lessonId = wp_insert_post($lessonData);

            if (is_wp_error($lessonId)) {
                error_log('Failed to create lesson: ' . $lessonId->get_error_message());
                continue;
            }

            // Store lesson reference in course meta
            $lessonKey = "{$sectionKey}_lesson_{$lessonIndex}";
            update_post_meta($courseId, "_mpcs_course_{$lessonKey}_id", $lessonId);
        }
    }

    /**
     * Add a section to the course
     */
    public function addSection(CourseSection $section): void
    {
        $section->setOrder(count($this->sections));
        $this->sections[] = $section;
    }

    /**
     * Remove a section by index
     */
    public function removeSection(int $index): bool
    {
        if (isset($this->sections[$index])) {
            array_splice($this->sections, $index, 1);
            $this->reorderSections();
            return true;
        }
        return false;
    }

    /**
     * Reorder sections after modification
     */
    private function reorderSections(): void
    {
        foreach ($this->sections as $index => $section) {
            $section->setOrder($index);
        }
    }

    /**
     * Move section to new position
     */
    public function moveSectionToPosition(int $fromIndex, int $toIndex): bool
    {
        if (!isset($this->sections[$fromIndex]) || $toIndex < 0 || $toIndex >= count($this->sections)) {
            return false;
        }

        $section = $this->sections[$fromIndex];
        array_splice($this->sections, $fromIndex, 1);
        array_splice($this->sections, $toIndex, 0, [$section]);
        
        $this->reorderSections();
        return true;
    }

    /**
     * Get section by index
     */
    public function getSection(int $index): ?CourseSection
    {
        return $this->sections[$index] ?? null;
    }

    /**
     * Find section by title
     */
    public function findSectionByTitle(string $title): ?CourseSection
    {
        foreach ($this->sections as $section) {
            if ($section->getTitle() === $title) {
                return $section;
            }
        }
        return null;
    }

    /**
     * Get total number of lessons across all sections
     */
    public function getTotalLessons(): int
    {
        $total = 0;
        foreach ($this->sections as $section) {
            $total += $section->getLessonCount();
        }
        return $total;
    }

    /**
     * Get estimated total course duration in minutes
     */
    public function getEstimatedDuration(): int
    {
        $total = 0;
        foreach ($this->sections as $section) {
            $total += $section->getTotalDuration();
        }
        return $total;
    }

    /**
     * Get estimated duration formatted as human-readable string
     */
    public function getFormattedDuration(): string
    {
        $minutes = $this->getEstimatedDuration();
        $hours = floor($minutes / 60);
        $remainingMinutes = $minutes % 60;

        if ($hours > 0) {
            return sprintf('%d hours %d minutes', $hours, $remainingMinutes);
        } else {
            return sprintf('%d minutes', $minutes);
        }
    }

    /**
     * Check if course has video content
     */
    public function hasVideoContent(): bool
    {
        foreach ($this->sections as $section) {
            if ($section->hasVideoLessons()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if course has downloadable resources
     */
    public function hasDownloadableResources(): bool
    {
        foreach ($this->sections as $section) {
            if ($section->hasDownloadableResources()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Get all learning objectives from course and sections
     */
    public function getAllLearningObjectives(): array
    {
        $allObjectives = $this->learningObjectives;
        
        foreach ($this->sections as $section) {
            $allObjectives = array_merge($allObjectives, $section->getAllObjectives());
        }
        
        return array_unique($allObjectives);
    }

    /**
     * Add learning objective
     */
    public function addLearningObjective(string $objective): void
    {
        if (!empty(trim($objective))) {
            $this->learningObjectives[] = trim($objective);
        }
    }

    /**
     * Add metadata field
     */
    public function addMetadata(string $key, $value): void
    {
        $this->metadata[$key] = $value;
    }

    /**
     * Get metadata field
     */
    public function getMetadata(string $key, $default = null)
    {
        return $this->metadata[$key] ?? $default;
    }

    // Getters and Setters
    public function getTitle(): string
    {
        return $this->title;
    }

    public function setTitle(string $title): void
    {
        $this->title = $title;
    }

    public function getDescription(): string
    {
        return $this->description;
    }

    public function setDescription(string $description): void
    {
        $this->description = $description;
    }

    public function getLearningObjectives(): array
    {
        return $this->learningObjectives;
    }

    public function setLearningObjectives(array $learningObjectives): void
    {
        $this->learningObjectives = $learningObjectives;
    }

    public function getSections(): array
    {
        return $this->sections;
    }

    public function setSections(array $sections): void
    {
        $this->sections = $sections;
        $this->reorderSections();
    }

    public function getTemplateType(): ?string
    {
        return $this->templateType;
    }

    public function setTemplateType(?string $templateType): void
    {
        $this->templateType = $templateType;
    }

    public function getAllMetadata(): array
    {
        return $this->metadata;
    }

    /**
     * Set difficulty level
     */
    public function setDifficultyLevel(string $difficultyLevel): void
    {
        $this->metadata['difficulty_level'] = $difficultyLevel;
    }

    /**
     * Get difficulty level
     */
    public function getDifficultyLevel(): string
    {
        return $this->metadata['difficulty_level'] ?? 'beginner';
    }

    /**
     * Get course as array for JSON serialization
     */
    public function toArray(): array
    {
        $sectionsArray = [];
        foreach ($this->sections as $section) {
            $sectionsArray[] = $section->toArray();
        }

        return [
            'title' => $this->title,
            'description' => $this->description,
            'learning_objectives' => $this->learningObjectives,
            'sections' => $sectionsArray,
            'metadata' => $this->metadata,
            'template_type' => $this->templateType,
            'total_lessons' => $this->getTotalLessons(),
            'estimated_duration' => $this->getEstimatedDuration(),
            'formatted_duration' => $this->getFormattedDuration(),
            'has_video' => $this->hasVideoContent(),
            'has_downloads' => $this->hasDownloadableResources(),
            'all_objectives' => $this->getAllLearningObjectives()
        ];
    }
}